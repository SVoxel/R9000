/**
 * board/annapurna-labs/alpine_db/board.c
 *
 * Thie file contains board specific functionality.
 * Board: Annapurna Labs Alpine Development Board
 *
 * Copyright (C) 2012 Annapurna Labs Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#include <errno.h>
#include <common.h>
#include <libfdt_env.h>
#include <fdt_support.h>
#include <libfdt.h>
#include <fdtdec.h>
#include <linux/compiler.h>
#include <asm/io.h>
#include <asm/global_data.h>
#include <spi.h>
#include <scsi.h>
#include <asm/arch/timer.h>
#include <malloc.h>
#include <spi_flash.h>
#include <i2c.h>

#include <al_globals.h>
#include <al_board.h>
#include <shared_params.h>
#include <al_eth.h>
#include <al_hal_pbs_regs.h>
#include <al_hal_nb_regs.h>
#include <al_hal_cmos_regs.h>
#include <al_hal_unit_adapter_regs.h>
#include <al_hal_addr_map.h>
#include <al_hal_nand_regs.h>
#include <al_hal_nand_coded_properties.h>

#include "dev_info_layout.h"
#include "early_init_layout.h"
#include "generated/version_autogenerated.h"
#include "lcd.h"
#include "board_cfg.h"
#include "eeprom_per_device.h"
#include "al_flash_contents.h"

#define I2C_ADDR_LEN		2

#define DT_OFFSET_STR      "dt_location"
#define I2C_PROBE_ADDR_STR "pld_i2c_addr"

#define PCI_REGS_IO_SYS_BASE_IDX	11
#define PCI_REGS_IO_SIZE_IDX		13
#define PCI_REGS_MEM_REAL_BASE_IDX	16
#define PCI_REGS_MEM_SYS_BASE_IDX	18
#define PCI_REGS_MEM_SIZE_IDX		20

#define NAND_CTRL_BASE_OFFSET		0x201000

#define DEV_INFO_FIELD(field)\
	((dev_info_buff[DEV_INFO_ ## field ## _OFFSET] &\
	 DEV_INFO_ ## field ## _MASK) >> DEV_INFO_ ## field ## _SHIFT)

DECLARE_GLOBAL_DATA_PTR;

static unsigned int dt_offset = 0xc0000; /* Default Value */
static unsigned int dt_is_from_toc;

static unsigned int i2c_mux_ch0_bus_id = 1;

/**
 * NAND read implementation
 *
 * following function pointer is set to the function's bootrom implementation
 *
 * @param	offset inside nand device
 * @param	address of memory buffer that will store read data
 * @param	size of read (in Bytes)
 *
 * @returns	0 if successful
 *		<0 otherwise
 */
int (*nand_read_ptr)(unsigned int, uint8_t*, unsigned int) =
		(void *)(uintptr_t)CONFIG_AL_BOOTROM_NAND_READ_FUNC_ADDR;

/**
 * NAND is bad block implementation
 *
 * following function pointer is set to the function's bootrom implementation
 *
 * @param	offset inside nand device
 * @param	word_size number of bytes per word
 * @param	spare_word_index location of bad block indication in the spare area
 * @param	bad 1 if the block is bad
 *
 * @returns	0 if successful
 *		<0 otherwise
 */
int (*nand_is_bad_block_ptr)(unsigned int, unsigned int, unsigned int, int *) =
		(void *)(uintptr_t)CONFIG_AL_BOOTROM_NAND_IS_BAD_BLOCK_FUNC_ADDR;

static struct al_pcie_cfg pcie_cfg[AL_SB_PCIE_NUM] = {
	{ .present = 1, .max_speed = AL_PCIE_LINK_SPEED_GEN3, .num_lanes = 4, .ep = 0 },
	{ .present = 1, .max_speed = AL_PCIE_LINK_SPEED_GEN3, .num_lanes = 4, .ep = 0 },
	{ .present = 1, .max_speed = AL_PCIE_LINK_SPEED_GEN3, .num_lanes = 4, .ep = 0 },
};

static struct {
	const enum al_muio_mux_if iface;
	const char *iface_str;
} ifaces_list[] = {
	{ AL_MUIO_MUX_IF_NOR_8,		"if_nor_8" },
	{ AL_MUIO_MUX_IF_NOR_16,	"if_nor_16" },
	{ AL_MUIO_MUX_IF_NOR_CS_0,	"if_nor_cs_0" },
	{ AL_MUIO_MUX_IF_NOR_CS_1,	"if_nor_cs_1" },
	{ AL_MUIO_MUX_IF_NOR_CS_2,	"if_nor_cs_2" },
	{ AL_MUIO_MUX_IF_NOR_CS_3,	"if_nor_cs_3" },
	{ AL_MUIO_MUX_IF_NOR_WP,	"if_nor_wp" },
	{ AL_MUIO_MUX_IF_NAND_8,	"if_nand_8" },
	{ AL_MUIO_MUX_IF_NAND_16,	"if_nand_16" },
	{ AL_MUIO_MUX_IF_NAND_CS_0,	"if_nand_cs_0" },
	{ AL_MUIO_MUX_IF_NAND_CS_1,	"if_nand_cs_1" },
	{ AL_MUIO_MUX_IF_NAND_CS_2,	"if_nand_cs_2" },
	{ AL_MUIO_MUX_IF_NAND_CS_3,	"if_nand_cs_3" },
	{ AL_MUIO_MUX_IF_NAND_WP,	"if_nand_wp" },
	{ AL_MUIO_MUX_IF_SRAM_8,	"if_sram_8" },
	{ AL_MUIO_MUX_IF_SRAM_16,	"if_sram_16" },
	{ AL_MUIO_MUX_IF_SRAM_CS_0,	"if_sram_cs_0" },
	{ AL_MUIO_MUX_IF_SRAM_CS_1,	"if_sram_cs_1" },
	{ AL_MUIO_MUX_IF_SRAM_CS_2,	"if_sram_cs_2" },
	{ AL_MUIO_MUX_IF_SRAM_CS_3,	"if_sram_cs_3" },
	{ AL_MUIO_MUX_IF_SATA_0_LEDS,	"if_sata_0_leds" },
	{ AL_MUIO_MUX_IF_SATA_1_LEDS,	"if_sata_1_leds" },
	{ AL_MUIO_MUX_IF_ETH_LEDS,	"if_eth_leds" },
	{ AL_MUIO_MUX_IF_ETH_GPIO,	"if_eth_gpio" },
	{ AL_MUIO_MUX_IF_UART_1,	"if_uart_1" },
	{ AL_MUIO_MUX_IF_UART_1_MODEM,	"if_uart_1_modem" },
	{ AL_MUIO_MUX_IF_UART_2,	"if_uart_2" },
	{ AL_MUIO_MUX_IF_UART_3,	"if_uart_3" },
	{ AL_MUIO_MUX_IF_I2C_GEN,	"if_i2c_gen" },
	{ AL_MUIO_MUX_IF_ULPI_0_RST_N,	"if_ulpi_0_rst_n" },
	{ AL_MUIO_MUX_IF_ULPI_1_RST_N,	"if_ulpi_1_rst_n" },
	{ AL_MUIO_MUX_IF_PCI_EP_INT_A,	"if_pci_ep_int_a" },
	{ AL_MUIO_MUX_IF_PCI_EP_RESET_OUT, "if_pci_ep_reset_out" },
	{ AL_MUIO_MUX_IF_SPIM_A_SS_1,	"if_spim_a_ss_1" },
	{ AL_MUIO_MUX_IF_SPIM_A_SS_2,	"if_spim_a_ss_2" },
	{ AL_MUIO_MUX_IF_SPIM_A_SS_3,	"if_spim_a_ss_3" },
	{ AL_MUIO_MUX_IF_ULPI_1_B,	"if_ulpi_1_b" },
	{ AL_MUIO_MUX_IF_GPIO,		"if_gpio" },
};

static unsigned int ifaces_num = sizeof(ifaces_list) / sizeof(ifaces_list[0]);

/* UART 1-3 to USB module present */
static int uart123_module_present;

/* Board ID */
static int board_id;

/* PCIe card presence - real */
static int pcie_prsnt_real[AL_SB_PCIE_NUM];

/*
 * this read function-pointer enables the system to choose boot device on
 * runtime, according to provided bootstrap
 */
int (*boot_read)(unsigned int, void *, unsigned int);

static int recovery;

static int obj_hdr_dt_valid;
static struct al_flash_obj_hdr obj_hdr_dt;
static unsigned int obj_hdr_dt_offset;

static int obj_hdr_uboot_script_valid;
static struct al_flash_obj_hdr obj_hdr_uboot_script;
static unsigned int obj_hdr_uboot_script_offset;

static unsigned int boot_instance_num_active;
static unsigned int boot_instance_num_non_active;

/* Get the required Ethernet board params reference clock frequency */
static enum al_eth_ref_clk_freq eth_board_params_ref_clk_freq_get(void)
{
	switch (al_globals.bootstraps.sb_clk_freq) {
	default:
		printf("%s: invalid SB clock frequency (%u)\n", __func__,
			al_globals.bootstraps.sb_clk_freq);
	case 375000000:
		return AL_ETH_REF_FREQ_375_MHZ;
	case 250000000:
		return AL_ETH_REF_FREQ_250_MHZ;
	case 500000000:
		return AL_ETH_REF_FREQ_500_MHZ;
	};
}

/* Detect board configuration according to GPINs */
static int board_cfg_detect(void)
{
#ifdef NO_BOARD_INFO_GPIO
	int err;
	int i;

	printf("Board configuration:\n");

	board_id = (gpio_get_value(GPIO_INDEX_BOARD_ID_2) << 2) |
		(gpio_get_value(GPIO_INDEX_BOARD_ID_1) << 1) |
		gpio_get_value(GPIO_INDEX_BOARD_ID_0);

	printf("- Board ID: %X - ", board_id);

	switch (board_id) {
	case BOARD_ID_GENERIC:
		printf("Generic\n");
		break;

	case BOARD_ID_ENDPOINT:
		printf("Endpoint\n");
		break;

	default:
		printf("Unknown!\n");
	}

	err = al_muio_mux_iface_free(
		&al_globals.muio_mux,
		AL_MUIO_MUX_IF_GPIO,
		GPIO_INDEX_BOARD_ID_0);
	if (err)
		printf("%s: al_muio_mux_iface_free(gpio board id 0) failed!\n",
			__func__);

	err = al_muio_mux_iface_free(
		&al_globals.muio_mux,
		AL_MUIO_MUX_IF_GPIO,
		GPIO_INDEX_BOARD_ID_1);
	if (err)
		printf("%s: al_muio_mux_iface_free(gpio board id 1) failed!\n",
			__func__);

	err = al_muio_mux_iface_free(
		&al_globals.muio_mux,
		AL_MUIO_MUX_IF_GPIO,
		GPIO_INDEX_BOARD_ID_2);
	if (err)
		printf("%s: al_muio_mux_iface_free(gpio board id 2) failed!\n",
			__func__);

	uart123_module_present = !gpio_get_value(GPIO_INDEX_RS232_EN);
	printf("- UART 1-3 module: %spresent\n",
		uart123_module_present ? "" : "not ");

	pcie_prsnt_real[0] = !gpio_get_value(GPIO_INDEX_PCIE0_PRSNT);
	pcie_prsnt_real[1] = !gpio_get_value(GPIO_INDEX_PCIE1_PRSNT) &&
		gpio_get_value(GPIO_INDEX_PCIE2SATA_PRSNTN);

	al_globals.pcie_cfg[0].present = pcie_prsnt_real[0];
	al_globals.pcie_cfg[1].present = pcie_prsnt_real[1];
	al_globals.pcie_cfg[2].present = 0;

	for (i = 0; i < AL_SB_PCIE_NUM; i++) {
		printf("- PCIe %d card: %spresent\n",
			i, al_globals.pcie_cfg[i].present ? "" : "not ");
	}

	/* Non endpoit boards:
	 * Mark as present anyway in order to try link anyway */
	if (board_id != BOARD_ID_ENDPOINT) {
		al_globals.pcie_cfg[0].present = 1;
		al_globals.pcie_cfg[1].present =
			gpio_get_value(GPIO_INDEX_PCIE2SATA_PRSNTN);
	/* Endpoint board:
	 * Mark as non present anyway in order to avoid link on endpoint */
	} else {
		al_globals.pcie_cfg[0].present = 0;
		al_globals.pcie_cfg[1].present = 0;
	}

	printf("- PCIe to SATA: %spresent\n",
		 gpio_get_value(GPIO_INDEX_PCIE2SATA_PRSNTN) ? "not " : "");

	printf("- SFP 0/1: %spresent\n",
		gpio_get_value(GPIO_INDEX_SFP_ABSNT_0_1) ? "not " : "");

	printf("- SFP 2/3: %spresent\n",
		gpio_get_value(GPIO_INDEX_SFP_ABSNT_2_3) ? "not " : "");
#endif /* ifdef NO_BOARD_INFO_GPIO */

	return 0;
}

int spi_boot_read(unsigned int offset, void *target, unsigned int size)
{
	int err;
	static struct spi_flash *flash = NULL;

	if (!flash)
		flash = spi_flash_probe(
			0, 0, CONFIG_SF_DEFAULT_SPEED, CONFIG_SF_DEFAULT_MODE);

	if (!flash)
		return -EIO;

	err = spi_flash_read(
		flash, offset, size, target);
	if (err)
		return err;

	return 0;
}

/*
 * When booting from UART, assume entire boot image was loaded through
 * UART, and set a recovery offset accordingly
 */
int recovery_mem_read(unsigned int offset, void *target, unsigned int size)
{
	memcpy(target, (uint8_t *)(uintptr_t)offset + 0x4000 - 0x3004, size);

	return 0;
}

static uint32_t nand_block_size_get(void)
{
	struct al_pbs_regs __iomem *pbs_regs =
			(struct al_pbs_regs __iomem *)AL_PBS_REGFILE_BASE;
	uint32_t block_size;
	uint32_t page_size;
	uint32_t reg;

	reg = al_reg_read32(&pbs_regs->unit.cfg_nand_0);

	page_size = 512 <<
			((reg & NAND_CODED_PROPERTIES_WORD_0_PAGE_SIZE_MASK) >>
				NAND_CODED_PROPERTIES_WORD_0_PAGE_SIZE_SHIFT);

	block_size = page_size * 16 *
			(1 << ((reg & NAND_CODED_PROPERTIES_WORD_0_BLOCK_SIZE_MASK)
				>> NAND_CODED_PROPERTIES_WORD_0_BLOCK_SIZE_SHIFT));

	return block_size;
}

static int nand_address_logical_to_physical(
	unsigned int	block_size,
	unsigned int	logical_address,
	unsigned int	*phys_address)
{
	int num_bad_blocks = 0;
	int logical_block_num = logical_address / block_size;
	int i;
	int is_bad;

	for (i = 0; i <= (logical_block_num + num_bad_blocks); i++) {
		if (0 != nand_is_bad_block_ptr(
			i * block_size,
			1,
			0,
			&is_bad))
			return -1;

		if (0 != is_bad)
			num_bad_blocks++;
	}


	*phys_address =
		logical_address + num_bad_blocks * block_size;

	if ((*phys_address) != logical_address)
		printf(
			"%s: %u --> %u\n",
			__func__,
			logical_address,
			*phys_address);

	return 0;
}

static void al_nand_tx_set_enable(
	int			enable)
{
	struct al_nand_regs __iomem *regs =
		(struct al_nand_regs __iomem *)(AL_NAND_BASE + NAND_CTRL_BASE_OFFSET);
	uint32_t reg_val;

	reg_val = al_reg_read32(&regs->ctl_reg0);

	AL_REG_BIT_VAL_SET(reg_val, AL_NAND_CTL_REG0_TX_MODE, enable);

	al_reg_write32(&regs->ctl_reg0, reg_val);
}

static int nand_read(unsigned int offset, void *target, unsigned int size)
{
	uint32_t block_size;
	uint32_t phys_address = 0;
	uint32_t next_block_offset;
	uint32_t num_bytes_current;
	int	 ret = 0;

	block_size = nand_block_size_get();

	while (size) {
		nand_address_logical_to_physical(block_size, offset, &phys_address);

		al_nand_tx_set_enable(1);
		al_nand_tx_set_enable(0);

		next_block_offset = (phys_address / block_size) * block_size + block_size;

		num_bytes_current = (size < (next_block_offset - phys_address)) ?
					size :
					(next_block_offset - phys_address);

		ret = nand_read_ptr(phys_address, target, num_bytes_current);

		if (ret) {
			printf("%s: nand read return failure (%d)\n", __func__, ret);
			return ret;
		}

		offset += num_bytes_current;
		size -= num_bytes_current;
		target += num_bytes_current;
	}

	return 0;
}

static int toc_parse(void)
{
	int err;
	int found_index;
	struct al_flash_toc_entry toc_entry;
	al_bool env_instance_fallback = AL_FALSE;

	err = al_flash_toc_search((al_flash_dev_read)boot_read,
		CONFIG_AL_FLASH_TOC_FIRST_OFFSET,
		CONFIG_AL_FLASH_TOC_SKIP_SIZE,
		CONFIG_AL_FLASH_TOC_MAX_NUM_SKIPS,
		&al_globals.toc_offset);
	if (err) {
		printf("al_flash_toc_search failed!\n");
		return err;
	}

	err = al_flash_toc_stage2_active_instance_get(
		(void *)AL_PBS_INT_MEM_SRAM_BASE,
		(al_flash_dev_read)boot_read, al_globals.toc_offset,
		&boot_instance_num_active);
	if (err) {
		printf("al_flash_toc_stage2_active_instance_get failed!\n");
		boot_instance_num_active = 0;
	}

	boot_instance_num_non_active = boot_instance_num_active ? 0 : 1;

	err = al_flash_toc_find_id((al_flash_dev_read)boot_read,
		al_globals.toc_offset, AL_FLASH_OBJ_ID(AL_FLASH_OBJ_ID_DT, boot_instance_num_active), 0, &found_index,
		&toc_entry);
	if (err) {
		printf("al_flash_toc_find_id failed!\n");
		goto get_uboot_script;
	}
	if (found_index < 0) {
		printf("DT not found in TOC!\n");
		goto get_uboot_script;
	}

	err = al_flash_obj_header_read_and_validate((al_flash_dev_read)boot_read, toc_entry.offset, &obj_hdr_dt);
	if (err) {
		printf("al_flash_obj_header_read_and_validate failed!\n");
		goto get_uboot_script;
	}

	obj_hdr_dt_offset = toc_entry.offset;
	obj_hdr_dt_valid = 1;

get_uboot_script:
	err = al_flash_toc_find_id((al_flash_dev_read)boot_read,
		al_globals.toc_offset, AL_FLASH_OBJ_ID(AL_FLASH_OBJ_ID_UBOOT_SCRIPT, boot_instance_num_active), 0, &found_index,
		&toc_entry);
	if (err) {
		printf("al_flash_toc_find_id failed!\n");
		goto get_env_offset;
	}
	if (found_index < 0) {
		printf("U-Boot script not found in TOC!\n");
		goto get_env_offset;
	}

	err = al_flash_obj_header_read_and_validate((al_flash_dev_read)boot_read, toc_entry.offset, &obj_hdr_uboot_script);
	if (err) {
		printf("al_flash_obj_header_read_and_validate failed!\n");
		goto get_env_offset;
	}

	obj_hdr_uboot_script_offset = toc_entry.offset;
	obj_hdr_uboot_script_valid = 1;

get_env_offset:
	err = al_flash_toc_find_id((al_flash_dev_read)boot_read,
		al_globals.toc_offset, AL_FLASH_OBJ_ID(AL_FLASH_OBJ_ID_UBOOT_ENV,
		env_instance_fallback ? 0 : boot_instance_num_active), 0, &found_index,
		&toc_entry);
	if (err) {
		printf("al_flash_toc_find_id failed!\n");
		goto get_env_offset_redund;
	}
	if (found_index < 0) {
		if ((!env_instance_fallback) && (boot_instance_num_active)) {
			printf("U-Boot environment not found in TOC - falling back to instance 0!\n");
			env_instance_fallback = AL_TRUE;
			goto get_env_offset;
		} else {
			printf("U-Boot environment not found in TOC!\n");
		}
		al_globals.env_offset_valid = 0;
		goto get_env_offset_redund;
	}

	al_globals.env_offset = toc_entry.offset;
	al_globals.env_offset_valid = 1;

get_env_offset_redund:
	err = al_flash_toc_find_id((al_flash_dev_read)boot_read,
		al_globals.toc_offset, AL_FLASH_OBJ_ID(AL_FLASH_OBJ_ID_UBOOT_ENV_RED,
		env_instance_fallback ? 0 : boot_instance_num_active), 0, &found_index,
		&toc_entry);
	if (err) {
		printf("al_flash_toc_find_id failed!\n");
		goto done;
	}
	if (found_index < 0) {
		printf("U-Boot redundant environment not found in TOC!\n");
		al_globals.env_redund_offset_valid = 0;
		goto done;
	}

	al_globals.env_redund_offset = toc_entry.offset;
	al_globals.env_redund_offset_valid = 1;

done:
	return 0;
}

static int dt_read(void)
{
	volatile uint8_t *dev_info_buff = (volatile uint8_t *)DEV_INFO_BASE;
	unsigned int early_init_addr;
	uint8_t early_init_info_buff[EARLY_INIT_SIZE];
	int err;

	working_fdt = malloc(CONFIG_AL_DT_MAX_SIZE);
	if (!working_fdt)
		return -ENOMEM;

	if (!dev_info_buff[DEV_INFO_DEV_ID_0_OFFSET]) {
		printf("Zero device ID!\n");
		early_init_addr = 0x400;
	} else {
		early_init_addr =
			((uint16_t)dev_info_buff[DEV_INFO_EARLY_INIT_ADDR_MSB_OFFSET]) << 8 |
			(uint16_t)dev_info_buff[DEV_INFO_EARLY_INIT_ADDR_LSB_OFFSET];
	}

	debug("Early init addr = %08x\n", early_init_addr);

	err = i2c_read(al_globals.bootstraps.i2c_preload_addr, early_init_addr,
			I2C_ADDR_LEN, early_init_info_buff, EARLY_INIT_SIZE);
	if (err)
		printf("%s: i2c read failed!\n", __func__);

	/*
	 * When boot from UART, assume entire boot image was loaded through
	 * UART
	 */
	if ((DEV_INFO_FIELD(RSVD_XMODEM_LOAD)) ||
		al_globals.bootstraps.boot_device == BOOT_DEVICE_UART) {
		boot_read = recovery_mem_read;
		recovery = 1;
	} else if (al_globals.bootstraps.boot_device == BOOT_DEVICE_NAND_8BIT) {
		boot_read = nand_read;
	} else {
		/* SPI FLASH */
		boot_read = spi_boot_read;
	}

	/* TOC parse */
	err = toc_parse();
	if (err)
		printf("%s: TOC parsing failed!\n", __func__);

	if (obj_hdr_dt_valid) {
		int err;

		err = al_flash_obj_data_load((al_flash_dev_read)boot_read, obj_hdr_dt_offset, working_fdt);
		if (err) {
			printf("al_flash_obj_data_load failed!\n");
			return -EINVAL;
		}

		dt_offset = obj_hdr_dt_offset;
		dt_is_from_toc = 1;
	} else {
		err = boot_read(dt_offset, working_fdt, CONFIG_AL_DT_MAX_SIZE);
		if (err)
			return err;
	}

	return 0;
}

static int dt_based_init_pinctrl(void)
{
	int off;
	const u32 *cell;
	const char *prop;
	const struct fdt_property *fdt_prop;
	int len;
	int i;
	int cell_idx;
	int err;

	off = fdt_path_offset(working_fdt, "/soc/board-cfg/pinctrl_init");
	if (off < 0) {
		printf("%s: pinctrl initialization node not found!\n", __func__);
		return -EINVAL;
	}

	fdt_prop = fdt_get_property(working_fdt, off, "pinctrl-0", &len);
	if (!fdt_prop) {
		printf("%s: property '%s' missing\n", __func__, "pinctrl-0");
		return -EINVAL;
	}

	cell = (u32 *)fdt_prop->data;
	len /= sizeof(u32);

	debug("Muxed interfaces:\n");

	for (cell_idx = 0; cell_idx < len; cell_idx++, cell++) {
		enum al_muio_mux_if iface;
		int iface_arg;

		off = fdt_node_offset_by_phandle(working_fdt, fdt32_to_cpu(*cell));

		prop = (char *)fdt_getprop(working_fdt, off, "id", NULL);
		if (!prop)
			return -EINVAL;

		iface_arg = fdtdec_get_int(working_fdt, off, "arg", 0);

		debug("\t%s(%d)\n", prop, iface_arg);

		for (i = 0; i < ifaces_num; ++i) {
			if (!strcmp(ifaces_list[i].iface_str, prop)) {
				iface = ifaces_list[i].iface;
				break;
			}
		}

		if (i == ifaces_num) {
			printf("%s: invalid iface (%s)!\n\n", __func__, prop);
			return -EINVAL;
		}

		err = al_muio_mux_iface_alloc(
			&al_globals.muio_mux,
			iface,
			iface_arg);
		if (err) {
			printf(
				"al_muio_mux_iface_alloc failed, either due to "
				"interface conflict, or syntax error!\n\n");
			return -1;

		}
	}

	return 0;
};

static int dt_based_init_gpio(void)
{
	int off;
	const u32 *cell;
	const struct fdt_property *fdt_prop;
	int len;
	int entry_idx;
	int err;
	struct gpio_cfg_ent gpio_cfg[AL_GPIO_TOTAL_PIN_AMOUNT];

	off = fdt_path_offset(working_fdt, "/soc/board-cfg/gpio_init");
	if (off < 0) {
		printf("%s: gpio initialization node not found!\n", __func__);
		return -EINVAL;
	}

	fdt_prop = fdt_get_property(working_fdt, off, "gpio-list", &len);
	if (!fdt_prop) {
		printf("%s: property '%s' missing\n", __func__, "gpio-list");
		return -EINVAL;
	}

	cell = (u32 *)fdt_prop->data;
	len /= sizeof(u32);

	debug("GPIO configuration:\n");

	if (len % 3) {
		printf("%s: property 'gpio-list' must contain GPIO triplets!\n",
			__func__);
		return -EINVAL;
	}

	len /= 3;

	for (entry_idx = 0; entry_idx < len; entry_idx++, cell += 3) {
		int gpio_num = fdt32_to_cpu(cell[0]);
		int is_output = fdt32_to_cpu(cell[1]);
		int output_val = fdt32_to_cpu(cell[2]);

		if (is_output)
			debug("\tGPIO %d is output, value = %d\n", gpio_num, output_val);
		else
			debug("\tGPIO %d is input\n", gpio_num);

		gpio_cfg[entry_idx].gpio_num = gpio_num;
		gpio_cfg[entry_idx].is_output = is_output;
		gpio_cfg[entry_idx].output_val = output_val;
	}

	err = gpio_board_init(gpio_cfg, len);
	if (err) {
		printf("%s: board gpio initialization failed!\n", __func__);
		return err;
	}

	return 0;
};

static int dt_based_init_eth_params_port(int port_idx)
{
	const struct fdt_property *fdt_prop;
	const char *prop;
	const u32 *cell;
	char path[80];
	int off;
	int len;
	struct al_eth_board_params *params =
		&al_globals.eth_board_params[port_idx];

	debug("Ethernet port %d:\n", port_idx);

	sprintf(path, "/soc/board-cfg/ethernet/port%d", port_idx);
	off = fdt_path_offset(working_fdt, path);
	if (off < 0) {
		printf("%s: ethernet port %d initialization node not found!\n",
				__func__, port_idx);
		return -EINVAL;
	}

	if (off < 0) {
		printf("%s: port%d wasn't found in the device tree\n",
			__func__, port_idx);

		return -EINVAL;
	}

	prop = (char *)fdt_getprop(working_fdt, off, "status", NULL);
	debug("\tstatus: %s\n", prop ? prop : "unknown - assuming enabled");
	if (prop && strcmp(prop, "enabled"))
		return 0;

	prop = (char *)fdt_getprop(working_fdt, off, "mode", NULL);
	debug("\tmode: %s\n", prop ? prop : "<unknown>");
	if (!prop)
		return -EINVAL;

	if (!strcmp(prop, "rgmii")) {
		params->media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
	} else {
		if (!strcmp(prop, "sgmii")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_SGMII;
		} else if (!strcmp(prop, "sgmii-2.5g")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_SGMII_2_5G;
		} else if (!strcmp(prop, "10g-serial")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_10GBASE_SR;
		} else if (!strcmp(prop, "auto-detect-auto-speed")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_AUTO_DETECT_AUTO_SPEED;
			params->sfp_plus_module_exist = AL_TRUE;
		} else if (!strcmp(prop, "auto-detect")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_AUTO_DETECT;
			params->sfp_plus_module_exist = AL_TRUE;
		} else if (!strcmp(prop, "nbase-t")) {
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_NBASE_T;
		/* backward compatibility */
		} else if (!strcmp(prop, "auto")) {
			printf("\tusing mode auto is deprecated! use auto-detect mode instead\n");
			params->media_type = AL_ETH_BOARD_MEDIA_TYPE_AUTO_DETECT;
			params->sfp_plus_module_exist = AL_TRUE;
		} else {
			return -EINVAL;
		}

		/* TODO: Might become dynamic */
		params->serdes_grp = 3;
		params->serdes_lane = 3 - port_idx;

		/* backward compatibility - replaced with auto-detect mode */
		sprintf(path, "/soc/board-cfg/ethernet/port%d/sfp-plus", port_idx);
		off = fdt_path_offset(working_fdt, path);
		if (off >= 0) {
			printf("\tusing sfp-plus is deprecated! use auto-detect mode instead\n");
			prop = (char *)fdt_getprop(working_fdt, off, "status", NULL);
			debug("\tSFP module status: %s\n", prop ? prop : "<unknown>");
			if (!prop || !strcmp(prop, "enabled")) {
				debug("\tSFP module: enabled\n");
				params->sfp_plus_module_exist = AL_TRUE;
			} else {
				debug("\tSFP module: disabled\n");
			}
		} else {
			debug("\tSFP module: N/A\n");
		}

		/* backward compatibility - shouldn't be under sfp-plus */
		if ((off >= 0) && (params->sfp_plus_module_exist == AL_TRUE)) {
			fdt_prop = fdt_get_property(working_fdt, off, "i2c-id", &len);
			if (fdt_prop) {
				int i2c_id;

				cell = (u32 *)fdt_prop->data;
				i2c_id = fdt32_to_cpu(cell[0]);
				debug("\tSFP module I2C ID: %d\n", i2c_id);
				params->i2c_adapter_id = i2c_id;
			} else {
				debug("\tproperty i2c-id is missing\n");
				params->i2c_adapter_id = 0;
			}
		}

		sprintf(path, "/soc/board-cfg/ethernet/port%d/10g-serial", port_idx);
		off = fdt_path_offset(working_fdt, path);
		if (off < 0) {
			/* backward compatibility */
			sprintf(path, "/soc/board-cfg/ethernet/port%d/10gbe", port_idx);
			off = fdt_path_offset(working_fdt, path);
			if (off >= 0)
				printf("\tusing 10gbe is deprecated! use 10g-serial instead\n");
		}

		if (off >= 0) {
			prop = (char *)fdt_getprop(working_fdt, off, "dac", NULL);
			debug("\t10gbe DAC: %s\n", prop ? prop : "<unknown>");
			if (prop && !strcmp(prop, "enabled"))
				params->dac = AL_TRUE;

			fdt_prop = fdt_get_property(working_fdt, off, "dac-length", &len);
			if (fdt_prop) {
				int len;

				cell = (u32 *)fdt_prop->data;
				len = fdt32_to_cpu(cell[0]);
				if ((len > 0) && (len < 16)) {
					debug("\t10gbe DAC len: %d\n", len);
					params->dac_len = len;
				} else {
					printf("dac-length has non-valid value. default to 3\n");
					params->dac_len = 3;
				}
			} else {
				params->dac_len = 3;
			}

			prop = (char *)fdt_getprop(working_fdt, off, "auto-neg", NULL);
			debug("\t10gbe auto-neg: %s\n", prop ? prop : "<unknown>");
			if (prop && !strcmp(prop, "enabled"))
				params->autoneg_enable = AL_TRUE;

			prop = (char *)fdt_getprop(working_fdt, off, "link-training", NULL);
			debug("\t10gbe link-training: %s\n", prop ? prop : "<unknown>");
			if (prop && !strcmp(prop, "enabled"))
				params->kr_lt_enable = AL_TRUE;

			prop = (char *)fdt_getprop(working_fdt, off, "fec", NULL);
			debug("\t10gbe fec: %s\n", prop ? prop : "<unknown>");
			if (prop && !strcmp(prop, "enabled"))
				params->kr_fec_enable = AL_TRUE;
		} else {
			debug("\t10gbe params: N/A\n");
		}
	}

	sprintf(path, "/soc/board-cfg/ethernet/port%d/ext_phy", port_idx);
	off = fdt_path_offset(working_fdt, path);

	if (off < 0) {
		/* backward compatibility */
		sprintf(path, "/soc/board-cfg/ethernet/port%d/rgmii", port_idx);
		off = fdt_path_offset(working_fdt, path);
		if (off >= 0)
			printf("\tusing rgmii is deprecated! use ext_phy instead\n");
	}

	if (off >= 0) {
		int phy_addr;

		params->phy_exist = AL_TRUE;
		fdt_prop = fdt_get_property(working_fdt, off, "phy-addr", &len);
		if (!fdt_prop) {
			/* RGMII must have phy addr */
			if (params->media_type == AL_ETH_BOARD_MEDIA_TYPE_RGMII) {
				printf("\tproperty phy-addr is missing\n");
				params->phy_mdio_addr = 0;
			} else {
				debug("\tphy is not exist\n");
			}
		} else {
			cell = (u32 *)fdt_prop->data;
			phy_addr = fdt32_to_cpu(cell[0]);
			debug("\tPHY address: %d\n", phy_addr);
			params->phy_mdio_addr = phy_addr;

			prop = (char *)fdt_getprop(working_fdt, off, "phy_mgmt_if", NULL);
			if (prop && !strcmp(prop, "mdc-mdio")) {
				params->phy_if = AL_ETH_BOARD_PHY_IF_MDIO;
			} else if (prop && !strcmp(prop, "xmdc-xmdio")) {
				params->phy_if = AL_ETH_BOARD_PHY_IF_XMDIO;
			} else if (prop && !strcmp(prop, "i2c")) {
				params->phy_if = AL_ETH_BOARD_PHY_IF_I2C;
			} else {
				printf("\tphy management interface is missing\n");
				params->phy_if = AL_ETH_BOARD_PHY_IF_MDIO;
			}

			prop = (char *)fdt_getprop(working_fdt, off, "mdc-mdio-freq", NULL);
			if (prop && !strcmp(prop, "2.5Mhz")) {
				params->mdio_freq = AL_ETH_BOARD_MDIO_FREQ_2_5_MHZ;
			} else if (prop && !strcmp(prop, "1.0Mhz")) {
				params->mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
			} else {
				debug("\tmdc-mdio-freq is missing\n");
				params->mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
			}

			prop = (char *)fdt_getprop(working_fdt, off, "auto-neg-mode", NULL);
			if (prop && !strcmp(prop, "in-band")) {
				params->an_mode = AL_ETH_BOARD_AUTONEG_IN_BAND;
			} else if (prop && !strcmp(prop, "out-of-band")) {
				params->an_mode = AL_ETH_BOARD_AUTONEG_OUT_OF_BAND;
			} else {
				printf("\tauto-negotiation mode is missing\n");
				params->an_mode = AL_ETH_BOARD_AUTONEG_OUT_OF_BAND;
			}
		}
	}

	sprintf(path, "/soc/board-cfg/ethernet/port%d/1g-serial", port_idx);
	off = fdt_path_offset(working_fdt, path);
	if (off >= 0) {
		prop = (char *)fdt_getprop(working_fdt, off, "auto-neg", NULL);
		if (prop && !strcmp(prop, "enabled")) {
			params->an_disable = AL_FALSE;
		} else if (prop && !strcmp(prop, "disabled")) {
			params->an_disable = AL_TRUE;
		} else {
			debug("\tauto-neg is missing. assume auto-neg enabled\n");
			params->an_disable = AL_FALSE;
		}

		prop = (char *)fdt_getprop(working_fdt, off, "speed", NULL);
		if (prop && !strcmp(prop, "1000M")) {
			params->speed = AL_ETH_BOARD_1G_SPEED_1000M;
		} else if (prop && !strcmp(prop, "100M")) {
			params->speed = AL_ETH_BOARD_1G_SPEED_100M;
		} else if (prop && !strcmp(prop, "10M")) {
			params->speed = AL_ETH_BOARD_1G_SPEED_10M;
		} else {
			debug("\tspeed is missing. assume speed 1000M\n");
			params->speed = AL_ETH_BOARD_1G_SPEED_1000M;
		}

		prop = (char *)fdt_getprop(working_fdt, off, "duplex", NULL);
		if (prop && !strcmp(prop, "full")) {
			params->half_duplex = AL_FALSE;
		} else if (prop && !strcmp(prop, "half")) {
			params->half_duplex = AL_TRUE;
		} else {
			debug("\tduplex is missing. assume full duplex\n");
			params->half_duplex = AL_FALSE;
		}
	}

	sprintf(path, "/soc/board-cfg/ethernet/port%d/retimer", port_idx);
	off = fdt_path_offset(working_fdt, path);

	if (off >= 0) {
		prop = (char *)fdt_getprop(working_fdt, off, "exist", NULL);
		debug("\tretimer exist: %s\n", prop ? prop : "<unknown>");
		if (prop && !strcmp(prop, "enabled")) {
			params->retimer_exist = AL_TRUE;
			prop = (char *)fdt_getprop(working_fdt, off, "type", NULL);
			if (prop && !strcmp(prop, "br410")) {
				params->retimer_type = AL_ETH_RETIMER_BR_410;
			} else {
				/* for backward compatibility assume BR_210
				 * retimer in case type is not exist.
				 */
				params->retimer_type = AL_ETH_RETIMER_BR_210;
			}

			fdt_prop = fdt_get_property(working_fdt, off, "i2c-bus", &len);
			if (fdt_prop) {
				cell = (u32 *)fdt_prop->data;
				params->retimer_bus_id = fdt32_to_cpu(cell[0]);
				debug("\tRetimer I2C bus ID: %d\n", params->retimer_bus_id);
			} else {
				printf("\tRetimer bus id: N/A\n");
			}

			fdt_prop = fdt_get_property(working_fdt, off, "i2c-addr", &len);
			if (fdt_prop) {
				cell = (u32 *)fdt_prop->data;
				params->retimer_i2c_addr = fdt32_to_cpu(cell[0]);
				debug("\tRetimer I2C address: %d\n", params->retimer_i2c_addr);
			} else {
				printf("\tRetimer bus addr: N/A\n");
			}

			prop = (char *)fdt_getprop(working_fdt, off, "channel", NULL);
			if (prop && !strcmp(prop, "A")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_A;
			} else if (prop && !strcmp(prop, "B")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_B;
			} else if (prop && !strcmp(prop, "C")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_C;
			} else if (prop && !strcmp(prop, "D")) {
				params->retimer_channel = AL_ETH_RETIMER_CHANNEL_D;
			} else {
				printf("\tretimer channel is missing\n");
			}
		}
	}

	sprintf(path, "/soc/board-cfg/ethernet/port%d/", port_idx);
	off = fdt_path_offset(working_fdt, path);

	fdt_prop = fdt_get_property(working_fdt, off, "i2c-id", &len);

	if (fdt_prop) {
		int i2c_id;

		cell = (u32 *)fdt_prop->data;
		i2c_id = fdt32_to_cpu(cell[0]);
		debug("\tSFP module I2C ID: %d\n", i2c_id);
		params->i2c_adapter_id = i2c_id;
	} else {
		debug("\ti2c-id: N/A\n");
	}

	prop = (char *)fdt_getprop(working_fdt, off, "freeze-serdes-params", NULL);
	if ((prop) && (!strcmp(prop, "enable")))
		params->dont_override_serdes = AL_TRUE;
	else
		params->dont_override_serdes = AL_FALSE;

	return 0;
}

static int dt_based_init_eth_params(void)
{
	enum al_eth_ref_clk_freq eth_ref_clk_freq =
		eth_board_params_ref_clk_freq_get();
	int err = 0;

	/* Update Ethernet board params */
	memset(al_globals.eth_board_params, 0, sizeof(al_globals.eth_board_params));

	al_globals.eth_board_params[0].ref_clk_freq = eth_ref_clk_freq;
	if (dt_based_init_eth_params_port(0)) {
		err = -EINVAL;
		al_globals.eth_board_params[0].sfp_plus_module_exist = AL_TRUE;
		al_globals.eth_board_params[0].phy_exist = AL_FALSE;
		al_globals.eth_board_params[0].media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
	}

	al_globals.eth_board_params[1].ref_clk_freq = eth_ref_clk_freq;
	if (dt_based_init_eth_params_port(1)) {
		err = -EINVAL;
		al_globals.eth_board_params[1].sfp_plus_module_exist = AL_FALSE;
		al_globals.eth_board_params[1].media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
		al_globals.eth_board_params[1].phy_exist = AL_TRUE;
		al_globals.eth_board_params[1].phy_mdio_addr = AL_ETH_PHY_ADDR_ETH1;
		al_globals.eth_board_params[1].phy_if = AL_ETH_BOARD_PHY_IF_MDIO;
		al_globals.eth_board_params[1].mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
	}

	al_globals.eth_board_params[2].ref_clk_freq = eth_ref_clk_freq;
	if (dt_based_init_eth_params_port(2)) {
		err = -EINVAL;
		al_globals.eth_board_params[2].sfp_plus_module_exist = AL_TRUE;
		al_globals.eth_board_params[2].phy_exist = AL_FALSE;
		al_globals.eth_board_params[2].media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
	}

	al_globals.eth_board_params[3].ref_clk_freq = eth_ref_clk_freq;
	if (dt_based_init_eth_params_port(3)) {
		err = -EINVAL;
		al_globals.eth_board_params[3].sfp_plus_module_exist = AL_FALSE;
		al_globals.eth_board_params[3].media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
		al_globals.eth_board_params[3].phy_exist = AL_TRUE;
		al_globals.eth_board_params[3].phy_mdio_addr = AL_ETH_PHY_ADDR_ETH3;
		al_globals.eth_board_params[3].phy_if = AL_ETH_BOARD_PHY_IF_MDIO;
		al_globals.eth_board_params[3].mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
	}

	return err;
}

static int dt_based_init_pcie_params_port(int port_idx)
{
	const struct fdt_property *fdt_prop;
	const char *prop;
	const u32 *cell;
	char path[80];
	int off;
	int len;
	struct al_pcie_cfg *params = &al_globals.pcie_cfg[port_idx];

	debug("PCIe port %d:\n", port_idx);

	sprintf(path, "/soc/board-cfg/pcie/port%d", port_idx);
	off = fdt_path_offset(working_fdt, path);
	if (off < 0) {
		printf("%s: PCIe port %d initialization node not found - assuming gen3x4!\n",
				__func__, port_idx);
		return 0;
	}

	prop = (char *)fdt_getprop(working_fdt, off, "status", NULL);
	debug("\tPCIe port status: %s\n", prop ? prop : "<unknown>");
	if (!prop || !strcmp(prop, "enabled"))
		params->present = 1;
	else
		params->present = 0;

	fdt_prop = fdt_get_property(working_fdt, off, "gen", &len);
	if (fdt_prop) {
		int gen;

		cell = (u32 *)fdt_prop->data;
		gen = fdt32_to_cpu(cell[0]);
		debug("\tGen: %d\n", gen);
		params->max_speed =
			(gen == 3) ? AL_PCIE_LINK_SPEED_GEN3 :
			(gen == 2) ? AL_PCIE_LINK_SPEED_GEN2 :
			AL_PCIE_LINK_SPEED_GEN1;
	}

	fdt_prop = fdt_get_property(working_fdt, off, "width", &len);
	if (fdt_prop) {
		int num_lanes;

		cell = (u32 *)fdt_prop->data;
		num_lanes = fdt32_to_cpu(cell[0]);
		debug("\tWidth: %d\n", num_lanes);
		params->num_lanes =
			(num_lanes == 4) ? 4 :
			(num_lanes == 2) ? 2 :
			1;
	}

	return 0;
}

static int dt_based_init_pcie(void)
{
	int off;
	const u32 *cell;
	const struct fdt_property *fdt_prop;
	int len;
	int i;

	off = fdt_path_offset(working_fdt, "/soc/board-cfg/pcie");
	if (off < 0) {
		debug("%s: pcie initialization node not found!\n", __func__);
		return 0;
	}

	fdt_prop = fdt_get_property(working_fdt, off, "ep-ports", &len);
	if (!fdt_prop) {
		debug("%s: property '%s' missing\n", __func__, "ep-ports");
		return 0;
	}

	cell = (u32 *)fdt_prop->data;
	len /= sizeof(u32);

	debug("PCIe endpoint ports:\n");

	for (i = 0; i < len; i++, cell++) {
		int port_num = fdt32_to_cpu(cell[0]);

		if ((port_num < 0) || (port_num >= AL_SB_PCIE_NUM)) {
			printf("%s: invalid port num (%d)!\n",
					__func__, port_num);
			continue;
		}

		debug("\tPCIe port %d is endpoint\n", port_num);
		al_globals.pcie_cfg[port_num].ep = 1;
	}

	dt_based_init_pcie_params_port(0);
	dt_based_init_pcie_params_port(1);
	dt_based_init_pcie_params_port(2);

	return 0;
};

static void dt_based_init(int *alpine_db_auto_cfg)
{
	const char *prop;
	int off;

	*alpine_db_auto_cfg = 0;

	debug("DT info:\n");
	debug("--------------------\n");

	off = fdt_path_offset(working_fdt, "/soc/board-cfg");
	if (off >= 0) {
		prop = (char *)fdt_getprop(working_fdt, off, "id", NULL);
		if (prop) {
			printf("Board config ID: %s\n", prop);

			if (!strcmp(prop, "alpine_db_auto")) {
				debug("alpine_db default config\n");
				*alpine_db_auto_cfg = 1;
				return;
			}
		} else {
			printf("%s: board id property not found!\n",
				__func__);
		}
	} else {
		printf("%s: board cfg initialization node not found!\n",
			__func__);
	}

	/* Set SPI baud rate according to DT */
	al_spi_baud_rate_set(AL_SPI_BAUD_RATE_DEFAULT);
	off = fdt_path_offset(working_fdt, "/soc/spi/spiflash@0");
	if (off >= 0) {
		const struct fdt_property *fdt_prop;
		u32 *cell;
		int len;

		fdt_prop = fdt_get_property(working_fdt, off, "spi-max-frequency", &len);
		if (fdt_prop) {
			cell = (u32 *)fdt_prop->data;
			al_spi_baud_rate_set(fdt32_to_cpu(cell[0]));
		}
	}

	/* Set NAND max ONFI timing mode according to DT */
	al_nand_max_onfi_timing_mode_set(AL_NAND_MAX_ONFI_TIMING_MODE_DEFAULT);
	off = fdt_path_offset(working_fdt, "/soc/nand-flash");
	if (off >= 0) {
		const struct fdt_property *fdt_prop;
		u32 *cell;
		int len;

		fdt_prop = fdt_get_property(working_fdt, off, "max-onfi-timing-mode", &len);
		if (fdt_prop) {
			cell = (u32 *)fdt_prop->data;
			al_nand_max_onfi_timing_mode_set(fdt32_to_cpu(cell[0]));
		}
	}

	/*
	 * Determine I2C mux channel 0 bus ID according to the presence of a secondary
	 * I2C controller.
	 * - If there's a secondary I2C controller, the I2C mux channel 0 bus ID is 2.
	 * - Otherwise it is 1.
	 * - This is dictated by Linux behavior.
	 */
	off = fdt_path_offset(working_fdt, "/soc/i2c-gen");
	if (off >= 0) {
		prop = (char *)fdt_getprop(working_fdt, off, "status", NULL);
		if (!prop && strcmp(prop, "disabled")) {
			i2c_mux_ch0_bus_id += 1;
			debug("%s: i2c_mux_ch0_bus_id = %u\n", __func__, i2c_mux_ch0_bus_id);
		}
	}

	if (dt_based_init_pinctrl())
		printf("%s: pinctrl initialization failed!\n", __func__);

	if (dt_based_init_gpio())
		printf("%s: gpio initialization failed!\n", __func__);

	if (dt_based_init_eth_params())
		printf("%s: ETH params initialization failed!\n", __func__);

	if (dt_based_init_pcie())
		printf("%s: pcie initialization failed!\n", __func__);

	/* SB PLL Initialization */
	/* PCIe set configuration */

	return;
}

unsigned int board_i2c_bus_id_convert(unsigned int id)
{
	if (id >= i2c_mux_ch0_bus_id) {
		id -= i2c_mux_ch0_bus_id;
		id += 1;
	}

	return id;
}

/*
 * Routine: board_init
 * Description: Early hardware init.
 */
int board_init(void)
{
	struct al_pbs_regs __iomem *pbs_regs =
		(struct al_pbs_regs __iomem *)AL_PBS_REGFILE_BASE;
	uint32_t reg_val;
	int err = 0;

	printf("\n");
	printf("   _\n");
	printf("  /_\\  _ __  _ __   __ _ _ __  _   _ _ __ _ __   __ _\n");
	printf(" //_\\\\| '_ \\| '_ \\ / _` | '_ \\| | | | '__| '_ \\ / _` |\n");
	printf("/  _  \\ | | | | | | (_| | |_) | |_| | |  | | | | (_| |\n");
	printf("\\_/ \\_/_| |_|_| |_|\\__,_| .__/ \\__,_|_|  |_| |_|\\__,_|\n");
	printf("   __       _           |_|\n");
	printf("  / /  __ _| |__  ___\n");
	printf(" / /  / _` | '_ \\/ __|\n");
	printf("/ /__| (_| | |_) \\__ \\\n");
	printf("\\____/\\__,_|_.__/|___/\n");
	printf("               ___             _\n");
	printf(" /\\ /\\        / __\\ ___   ___ | |_\n");
	printf("/ / \\ \\_____ /__\\/// _ \\ / _ \\| __|\n");
	printf("\\ \\_/ /_____/ \\/  \\ (_) | (_) | |_\n");
	printf(" \\___/      \\_____/\\___/ \\___/ \\__|\n");
	printf("\n");

	/* Read chip device and device revision ID */
	reg_val = readl(&pbs_regs->unit.chip_id);
	al_globals.dev_id = (reg_val & PBS_UNIT_CHIP_ID_DEV_ID_MASK) >>
		PBS_UNIT_CHIP_ID_DEV_ID_SHIFT;
	al_globals.rev_id = (reg_val & PBS_UNIT_CHIP_ID_DEV_REV_ID_MASK) >>
		PBS_UNIT_CHIP_ID_DEV_REV_ID_SHIFT;

	/* adress of boot parameters */
	gd->bd->bi_boot_params = 0x00000100;

	err = bootstrap_read_and_parse(
		&al_globals.bootstraps);
	if (err)
		printf("%s: bootstrap_read_and_parse failed!\n", __func__);

	/* SB PLL Initialization */
	err = pll_sb_init(pll_sb_cfg, ARRAY_SIZE(pll_sb_cfg));
	if (err)
		printf("%s: SB PLL initialization failed!\n", __func__);

	/* MPP Mux Initialization (without allocation) */
	err = al_muio_mux_init(
		(void __iomem *)AL_PBS_REGFILE_BASE,
		"muio_mux",
		&al_globals.muio_mux);
	if (err) {
		printf("al_muio_mux_init failed!\n");
		return -1;
	}

	/* SerDes handle initialization */
	err = al_serdes_handle_init(
		(void __iomem *)AL_SB_SERDES_BASE,
		&al_globals.serdes);
	if (err) {
		printf("al_serdes_handle_init failed!\n");
		return -1;
	}

#ifdef CONFIG_SPI_FLASH
	spi_init();
#endif

	return err;
}

int board_init_alpine_db_auto(void)
{
	enum al_eth_ref_clk_freq eth_ref_clk_freq =
		eth_board_params_ref_clk_freq_get();
	int err = 0;

	/* Board GPIO initializations */
	err = gpio_board_init(gpio_cfg, ARRAY_SIZE(gpio_cfg));
	if (err)
		printf("%s: board gpio initialization failed!\n", __func__);

	/* Board configuration detection */
	err = board_cfg_detect();
	if (err)
		printf("%s: board configuration detection failed!\n", __func__);

	/* Mux board interfaces - not including board GPIOs */
	if (uart123_module_present)
		err = al_muio_mux_iface_alloc_multi(
			&al_globals.muio_mux,
			muio_mux_ifaces_with_uart123,
			ARRAY_SIZE(muio_mux_ifaces_with_uart123));
	else
		err = al_muio_mux_iface_alloc_multi(
			&al_globals.muio_mux,
			muio_mux_ifaces,
			ARRAY_SIZE(muio_mux_ifaces));
	if (err)
		printf("%s: mpp mux initialization failed!\n", __func__);

	/* Update Ethernet board params */
	memset(al_globals.eth_board_params, 0, sizeof(al_globals.eth_board_params));

	/* ETH 0 Board Parameters */
	al_globals.eth_board_params[0].ref_clk_freq = eth_ref_clk_freq;
	al_globals.eth_board_params[0].mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
	al_globals.eth_board_params[0].sfp_plus_module_exist = AL_TRUE;
	al_globals.eth_board_params[0].i2c_adapter_id = 1;
	al_globals.eth_board_params[0].phy_exist = AL_FALSE;
	al_globals.eth_board_params[0].media_type = AL_ETH_BOARD_MEDIA_TYPE_AUTO_DETECT_AUTO_SPEED;
	al_globals.eth_board_params[0].dac = AL_TRUE;
	al_globals.eth_board_params[0].dac_len = 3;
	/* TODO: Might become dynamic */
	al_globals.eth_board_params[0].serdes_grp = 3;
	al_globals.eth_board_params[0].serdes_lane = 3;

	/* ETH 1 Board Parameters */
	al_globals.eth_board_params[1].ref_clk_freq = eth_ref_clk_freq;
	al_globals.eth_board_params[1].mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
	al_globals.eth_board_params[1].sfp_plus_module_exist = AL_FALSE;
	al_globals.eth_board_params[1].media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
	al_globals.eth_board_params[1].phy_exist = AL_TRUE;
	al_globals.eth_board_params[1].phy_mdio_addr = AL_ETH_PHY_ADDR_ETH1;

	/* ETH 2 Board Parameters */
	al_globals.eth_board_params[2].ref_clk_freq = eth_ref_clk_freq;
	al_globals.eth_board_params[2].mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
	al_globals.eth_board_params[2].sfp_plus_module_exist = AL_TRUE;
	al_globals.eth_board_params[2].i2c_adapter_id = 3;
	al_globals.eth_board_params[2].phy_exist = AL_FALSE;
	al_globals.eth_board_params[2].media_type = AL_ETH_BOARD_MEDIA_TYPE_AUTO_DETECT_AUTO_SPEED;
	al_globals.eth_board_params[2].dac = AL_TRUE;
	al_globals.eth_board_params[2].dac_len = 3;
	/* TODO: Might become dynamic */
	al_globals.eth_board_params[2].serdes_grp = 3;
	al_globals.eth_board_params[2].serdes_lane = 1;

	/* ETH 3 Board Parameters */
	al_globals.eth_board_params[3].ref_clk_freq = eth_ref_clk_freq;
	al_globals.eth_board_params[3].mdio_freq = AL_ETH_BOARD_MDIO_FREQ_1_MHZ;
	al_globals.eth_board_params[3].sfp_plus_module_exist = AL_FALSE;
	al_globals.eth_board_params[3].media_type = AL_ETH_BOARD_MEDIA_TYPE_RGMII;
	al_globals.eth_board_params[3].phy_exist = AL_TRUE;
	al_globals.eth_board_params[3].phy_mdio_addr = AL_ETH_PHY_ADDR_ETH3;

	return err;
}

int power_init_board(void)
{
	int alpine_db_auto_cfg;
	int eeprom_per_device_is_valid;

	int err = 0;

	/* PCIe set configuration */
	al_globals.pcie_cfg = pcie_cfg;
	al_globals.pcie_any_link_up = AL_FALSE;

	/* I2C initialization */
	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);

	err = eeprom_per_device_init(&eeprom_per_device_is_valid);
	if (err)
		printf("%s: EEPROM per device initialization failed!\n", __func__);
	if (err || (!eeprom_per_device_is_valid))
		printf("%s: EEPROM per device information is not valid - using defaults!\n", __func__);

	/* Device tree read */
	err = dt_read();
	if (err)
		printf("%s: DT reading failed!\n", __func__);

	/* Device tree based initialization */
	dt_based_init(&alpine_db_auto_cfg);

	if (alpine_db_auto_cfg)
		board_init_alpine_db_auto();

	lcd_init();

	lcd_cursor_set(0, 0);
	lcd_puts("AL-Boot");
	lcd_cursor_set(1, 0);
	lcd_puts(EXTRAVERSION);

	return 0;
}

static void board_setenv_ifndef(const char *key, const char *val)
{
	if (!getenv(key))
		setenv(key, val);
}

static void board_set_environment(void)
{
	board_setenv_ifndef(
		"fwupd",
		"tftpboot ${tftpdir}uboot_script_fw_update.bin;"
		"source ${loadaddr}");

	if (!getenv("dt_is_from_toc")) {
		if (dt_is_from_toc)
			setenv("dt_is_from_toc", "1");
		else
			setenv("dt_is_from_toc", "0");
	}

	if (!getenv("dt_filename")) {
		if (dt_is_from_toc)
			setenv("dt_filename", "dt.img");
		else
			setenv("dt_filename", "alpine_db.dtb");
	}

	if (recovery)
		setenv("bootcmd", "echo recovery boot command!");
}

int board_late_init(void)
{
	uint8_t *dev_info_buff = (uint8_t *)DEV_INFO_BASE;

	setenv_hex(DT_OFFSET_STR, dt_offset);
	setenv_hex(I2C_PROBE_ADDR_STR, al_globals.bootstraps.i2c_preload_addr);
	setenv_hex("boot_instance_active", boot_instance_num_active);
	setenv_hex("boot_instance_non_active", boot_instance_num_non_active);
	setenv_hex("env_offset", al_config_env_offset_get());
	if (al_config_env_offset_redund_get())
		setenv_hex("env_offset_redund", al_config_env_offset_redund_get());

	board_set_environment();

	set_working_fdt_addr(working_fdt);

	if (obj_hdr_uboot_script_valid) {
		void *script_buff;
		int err;

		script_buff = malloc(obj_hdr_uboot_script.size);
		if (!script_buff) {
			printf("Failed allocating memory for U-Boot script!\n");
			goto uboot_script_done;
		}

		err = al_flash_obj_data_load((al_flash_dev_read)boot_read,
				obj_hdr_uboot_script_offset, script_buff);
		if (err) {
			printf("Failed loading U-Boot script!\n");
			goto uboot_script_done_free;
		}

		err = source((ulong)script_buff, NULL);
		if (err) {
			printf("Failed executing U-Boot script!\n");
			goto uboot_script_done_free;
		}

uboot_script_done_free:
		free(script_buff);
uboot_script_done:
		;
	}

	if (al_globals.bootstraps.i2c_preload != I2C_PRELOAD_ENABLED)
		printf(
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"\n"
			"\n"
			"             I2C Preload Disabled!\n"
			"\n"
			"\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");

	if (!dev_info_buff[DEV_INFO_DEV_ID_0_OFFSET])
		printf(
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"\n"
			"\n"
			"   Bootstraps / DT / Capabilities Mismatch!\n"
			"\n"
			"\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");

	return 0;
}

#if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
static void ft_board_setup_clock(
	void		*blob,
	const char	*path,
	const char	*prop,
	uint32_t	cpu_val)
{
	uint32_t fdt_val = cpu_to_fdt32(cpu_val);

	debug("%s: setting %s.%s to %u Hz\n", __func__, path, prop, cpu_val);
	if (fdt_find_and_setprop(
		blob, path, prop, &fdt_val, sizeof(fdt_val), 0))
		printf("%s: unable to set %s.%s!\n", __func__, path, prop);
}

static void ft_board_setup_feature_disable(
	void		*blob,
	const char	*path)
{
	const char *status = "disabled";

	debug("%s: setting %s.status to disabled\n", __func__, path);
	if (fdt_find_and_setprop(
		blob, path, "status", status, strlen(status) + 1, 1))
		printf("%s: unable to set %s.status!\n", __func__, path);
}

static void ft_board_setup_prop_u32_set(
	void		*blob,
	const char	*path,
	const char	*prop,
	uint32_t	val)
{
	uint32_t fdt_val = cpu_to_fdt32(val);

	debug("%s: setting %s.%s to %u\n", __func__, path, prop, val);
	if (fdt_find_and_setprop(
		blob, path, prop, &fdt_val, sizeof(fdt_val), 0))
		printf("%s: unable to set %s.%s!\n", __func__, path, prop);
}

static void ft_board_setup_pcie_set(
	void		*blob,
	const char	*path,
	const char	*prop,
	al_phys_addr_t	base,
	uint32_t	size)
{
	int off;
	u32 *cell;
	const struct fdt_property *fdt_prop;
	int len;
	int err;

	off = fdt_path_offset(working_fdt, path);
	if (off < 0) {
		printf("%s: %s node not found!\n", __func__, path);
		return;
	}

	fdt_prop = fdt_get_property_w(working_fdt, off, prop, &len);
	if (!fdt_prop) {
		printf("%s: property '%s' missing\n", __func__, prop);
		return;
	}

	if (len < (PCI_REGS_MEM_SIZE_IDX * sizeof(u32))) {
		printf("%s: property length is smaller then expected\n", __func__);
		return;
	}

	cell = (u32 *)fdt_prop->data;

	cell[PCI_REGS_IO_SYS_BASE_IDX] = cpu_to_fdt32(base);
	base += fdt32_to_cpu(cell[PCI_REGS_IO_SIZE_IDX]);
	size -= fdt32_to_cpu(cell[PCI_REGS_IO_SIZE_IDX]);
	cell[PCI_REGS_MEM_REAL_BASE_IDX] = cpu_to_fdt32(base);
	cell[PCI_REGS_MEM_SYS_BASE_IDX] = cpu_to_fdt32(base);
	cell[PCI_REGS_MEM_SIZE_IDX] = cpu_to_fdt32(size);

	err = fdt_find_and_setprop(working_fdt, path, prop, cell, len, 1);
	if (err) {
		printf("Unable to update property %s, err=%s\n",
		       prop, fdt_strerror(err));
		return;
	}
}

int ft_board_setup(void *blob, bd_t *bd)
{
	struct al_nb_regs __iomem *nb_regs =
		(struct al_nb_regs __iomem *)AL_NB_SERVICE_BASE;
	struct al_pbs_regs __iomem *pbs_regs =
		(struct al_pbs_regs __iomem *)AL_PBS_REGFILE_BASE;
	al_phys_addr_t base;
	uint32_t log2size;
	uint32_t fdt_u32;

	ft_board_setup_clock(
		blob, "/soc/clocks/refclk", "clock-frequency",
		al_globals.bootstraps.pll_ref_clk_freq);
	ft_board_setup_clock(
		blob, "/soc/clocks/sbclk", "clock-frequency",
		al_globals.bootstraps.sb_clk_freq);
	ft_board_setup_clock(
		blob, "/soc/clocks/nbclk", "clock-frequency",
		al_globals.bootstraps.ddr_pll_freq);

	fdt_u32 = cpu_to_fdt32(al_globals.bootstraps.cpu_pll_freq);
	do_fixup_by_compat(blob, "arm,cortex-a15", "clock-frequency", &fdt_u32,
			   sizeof(fdt_u32), 0);

	fdt_u32 = cpu_to_fdt32(al_globals.bootstraps.ddr_pll_freq /
		(1 + ((al_reg_read32(&nb_regs->system_counter.cnt_control) &
		NB_SYSTEM_COUNTER_CNT_CONTROL_SCALE_MASK) >>
		NB_SYSTEM_COUNTER_CNT_CONTROL_SCALE_SHIFT)));
	do_fixup_by_compat(blob, "arm,cortex-a15-timer", "clock-frequency",
			   &fdt_u32, sizeof(fdt_u32), 0);

	fdt_u32 = cpu_to_fdt32(al_globals.bootstraps.sb_clk_freq);
	do_fixup_by_compat(blob, "ns16550a", "clock-frequency",
			   &fdt_u32, sizeof(fdt_u32), 0);

	if (!al_globals.pcie_cfg[0].present || al_globals.pcie_cfg[0].ep)
		ft_board_setup_feature_disable(blob, "/soc/pcie-external0");
	if (!al_globals.pcie_cfg[1].present || al_globals.pcie_cfg[1].ep)
		ft_board_setup_feature_disable(blob, "/soc/pcie-external1");
	if (!al_globals.pcie_cfg[2].present || al_globals.pcie_cfg[2].ep)
		ft_board_setup_feature_disable(blob, "/soc/pcie-external2");
	if (getenv_ulong("iocc_force", 10, 0)) {
		unsigned long val = getenv_ulong("iocc_force_val", 10, 1);

		printf(
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
			"I/O CC forced to %lu!\n"
			"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n",
			val);
		if (fdt_path_offset(blob, "/soc/ccu") >= 0)
			ft_board_setup_prop_u32_set(
				blob, "/soc/ccu", "io_coherency", val);
		else
			ft_board_setup_prop_u32_set(
				blob, "/soc/al-fabric", "io_coherency", val);
	}

	al_addr_map_pasw_get(pbs_regs, AL_ADDR_MAP_PASW_PCIE_EXT_MEM0, &base, &log2size);
	ft_board_setup_pcie_set(blob, "/soc/pcie-external0", "ranges",
				base, AL_BIT(log2size));

	al_addr_map_pasw_get(pbs_regs, AL_ADDR_MAP_PASW_PCIE_EXT_MEM1, &base, &log2size);
	ft_board_setup_pcie_set(blob, "/soc/pcie-external1", "ranges",
				base, AL_BIT(log2size));

	al_addr_map_pasw_get(pbs_regs, AL_ADDR_MAP_PASW_PCIE_EXT_MEM2, &base, &log2size);
	ft_board_setup_pcie_set(blob, "/soc/pcie-external2", "ranges",
				base, AL_BIT(log2size));

	/* TODO: fill /soc/arch-timer.clock_frequency */

	return 0;
}
#endif

#ifdef CONFIG_BOARD_EARLY_INIT_F
int board_early_init_f(void)
{
	return 0;
}
#endif	/* EARLY_INIT */

int dram_init(void)
{
	struct shared_parameters *shared_params = shared_params_ptr_get();

	if (shared_params->ddr_size > SZ_64M)
		gd->ram_size = SZ_64M;
	else
		gd->ram_size = (phys_size_t)shared_params->ddr_size;

	return 0;
}

void dram_init_banksize(void)
{
	const char *origin;
	uint64_t ddr_size;

	if (shared_params_valid()) {
		struct shared_parameters *shared_params =
			shared_params_ptr_get();

		ddr_size = shared_params->ddr_size;
		origin = "shared params";
	} else {
		ddr_size = SZ_512M;
		origin = "default";
	}

	debug("DDR size is %d MB according to %s\n",
		(int)(ddr_size / SZ_1M), origin);

	/* Define 4 memory banks according to DDR size */
	if (ddr_size == (4 * (uint64_t)SZ_1G)) {
		gd->bd->bi_dram[0].start = 0x0000000000000000ULL;
		gd->bd->bi_dram[0].size =  0x0000000040000000ULL;
		gd->bd->bi_dram[1].start = 0x0000000040000000ULL;
		gd->bd->bi_dram[1].size =  0x0000000040000000ULL;
		gd->bd->bi_dram[2].start = 0x0000000080000000ULL;
		gd->bd->bi_dram[2].size =  0x0000000040000000ULL;
		gd->bd->bi_dram[3].start = 0x0000000200000000ULL;
		gd->bd->bi_dram[3].size =  0x0000000040000000ULL;
	} else if (ddr_size == (8 * (uint64_t)SZ_1G)) {
		gd->bd->bi_dram[0].start = 0x0000000000000000ULL;
		gd->bd->bi_dram[0].size =  0x0000000080000000ULL;
		gd->bd->bi_dram[1].start = 0x0000000080000000ULL;
		gd->bd->bi_dram[1].size =  0x0000000040000000ULL;
		gd->bd->bi_dram[2].start = 0x0000000200000000ULL;
		gd->bd->bi_dram[2].size =  0x0000000040000000ULL;
		gd->bd->bi_dram[3].start = 0x0000000100000000ULL;
		gd->bd->bi_dram[3].size =  0x0000000100000000ULL;
	} else if (ddr_size == (16 * (uint64_t)SZ_1G)) {
		gd->bd->bi_dram[0].start = 0x0000000000000000ULL;
		gd->bd->bi_dram[0].size =  0x0000000080000000ULL;
		gd->bd->bi_dram[1].start = 0x0000000400000000ULL;
		gd->bd->bi_dram[1].size =  0x0000000080000000ULL;
		gd->bd->bi_dram[2].start = 0x0000000100000000ULL;
		gd->bd->bi_dram[2].size =  0x0000000100000000ULL;
		gd->bd->bi_dram[3].start = 0x0000000200000000ULL;
		gd->bd->bi_dram[3].size =  0x0000000200000000ULL;
	} else {
		int i;

		if (ddr_size > (3 * (uint64_t)SZ_1G)) {
			printf("%s: DDR size not supported!\n", __func__);
			ddr_size = (3 * (uint64_t)SZ_1G);
		}

		for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
			gd->bd->bi_dram[i].start =
				i * (ddr_size / CONFIG_NR_DRAM_BANKS);
			gd->bd->bi_dram[i].size =
				ddr_size / CONFIG_NR_DRAM_BANKS;
		}
	}
}

#ifdef CONFIG_AL_ETH
struct retimer_params {
	al_bool	valid;
	enum al_eth_retimer_type type;
	uint8_t	bus_id;
	uint8_t	addr;
};

struct retimer_config_reg {
	uint8_t addr;
	uint8_t val;
};

struct retimer_configuration {
	struct retimer_config_reg *config;
	uint32_t size;
};

static struct retimer_config_reg retimer_br210_configuration[] = {
	/* Clearing SMB Register to default. */
	{.addr = 0x7, .val = 0x41},
	/*
	 * Enabling Tx#A and Tx#B.
	 * Enabling Eq Stage 4 on RX#A & Rx#B.
	 */
	{.addr = 0x6, .val = 0x18},
	/*
	 * Enable Overriding Idle thresholds.
	 * Enable Overriding output Mode.
	 * Enable Overriding outputDeEmphasis.
	 */
	{.addr = 0x4, .val = 0x23},
	/* Set #A Normal Equalizer operation mode. */
	{.addr = 0x8, .val = 0x46},
	/* Setting Tx#A DeEmphasis to 0. */
	{.addr = 0x10, .val = 0xed},
	/* Setting Tx#A DeEmphasis to 0. */
	{.addr = 0x11, .val = 0x80},
	/*
	 * Setting Tx#A Idle D Threshold=110mV.
	 * Setting Tx#A Idle A Threshold=180mV.
	 * Setting Tx#A Slow OOB enabled.
	 */
	{.addr = 0x12, .val = 0x80},
	/* Setting Tx#A Amplitude to 700mVpp */
	{.addr = 0x25, .val = 0xad},
	/* Set #B Normal Equalizer operation mode. */
	{.addr = 0x17, .val = 0xed},
	/* Setting Tx#B DeEmphasis to 0. */
	{.addr = 0x18, .val = 0x80},
	/*
	 * Setting Tx#B Idle D Threshold=110mV.
	 * Setting Tx#B Idle A Threshold=180mV.
	 * Setting Tx#B Slow OOB enabled.
	 */
	{.addr = 0x19, .val = 0x80},
	/* Setting Tx#B Amplitude to 700mVpp */
	{.addr = 0x2d, .val = 0xad},
};

static struct retimer_config_reg retimer_br410_configuration[] = {
	/* Allow channel EN and EQ boost to be set by I2C. */
	{.addr = 0x7, .val = 0x1},
	/*
	 *  Set Tx to 1000mV
	 */
	{.addr = 0x8, .val = 0x8},
	/*
	 * Set Tx-DE to 0 for all ports
	 */
	{.addr = 0x11, .val = 0x0},
	/* Enable all channels */
	{.addr = 0x13, .val = 0x10},
	{.addr = 0x15, .val = 0x10},
	{.addr = 0x17, .val = 0x10},
	{.addr = 0x19, .val = 0x10},
	/* OOB Signal Detect Enable */
	{.addr = 0x12, .val = 0x6},
};

static struct retimer_configuration retimer_configuration[AL_ETH_RETIMER_TYPE_MAX] = {
	{.config = retimer_br210_configuration, .size = ARRAY_SIZE(retimer_br210_configuration) },
	{.config = retimer_br410_configuration, .size = ARRAY_SIZE(retimer_br410_configuration) },
	{.config = NULL, .size = 0 },
	{.config = NULL, .size = 0 },
};

int al_eth_retimer_init(uint8_t retimer_type, uint8_t bus_id, uint8_t addr)
{
	int rc = 0;
	int i;
	uint8_t val;
	struct retimer_config_reg *retimer_config = retimer_configuration[retimer_type].config;

	debug("%s: bus_id %x , addr %x\n", __func__, bus_id, addr);

	/* select the correct i2c module by muxing the i2c switch */
	rc = i2c_set_bus_num(bus_id);
	if (rc)
		goto i2c_error;

	rc = i2c_read(addr, 0x51, 1, &val, 1);
	if (rc)
		goto i2c_error;

	debug("%s: retimer id 0x%x\n", __func__, val);

	for (i = 0; i < retimer_configuration[retimer_type].size; i++) {
		debug("%s: (bus: %x, i2c-addr: %x) writing %x to i2c addr %x\n",
		      __func__, bus_id, addr, retimer_config[i].val,
		      retimer_config[i].addr);
		rc = i2c_write(addr,
			       retimer_config[i].addr,
			       1,
			       &retimer_config[i].val,
			       1);
		if (rc)
			goto i2c_error;
	}

	return 0;

i2c_error:
	printf("%s: Configuring retimer failed (%02x:%02x). assume no retimer exist\n", __func__, bus_id, addr);
	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
	return rc;
}

int board_eth_init(bd_t *bis)
{
	int port;
	int i;
	int err;
	struct retimer_params retimer_params[4] = {
		{ .valid = AL_FALSE },
		{ .valid = AL_FALSE },
		{ .valid = AL_FALSE },
		{ .valid = AL_FALSE } };

	/*
	 * In Alpine revision 0 disable RGMII_A and RGMII_B internal delay
	 * (because PHY applies delay)
	 * In newer revisions this is the default
	 */
	if ((al_globals.dev_id == AL_CHIP_DEV_ID_ALPINE) &&
		(al_globals.rev_id == 0)) {
		struct al_cmos_regs_m0 __iomem *cmos2_regs =
			(struct al_cmos_regs_m0 __iomem *)AL_CMOS_GROUP_BASE(2);
		struct al_cmos_regs_m0 __iomem *cmos3_regs =
			(struct al_cmos_regs_m0 __iomem *)AL_CMOS_GROUP_BASE(3);

		writel(0, &cmos2_regs->rgmii_dly_ctl);
		writel(0, &cmos3_regs->rgmii_dly_ctl);
	}

	for (port = 0; port < 4; port++) {
		struct al_eth_board_params *board_params = &al_globals.eth_board_params[port];

		if (board_params->retimer_exist) {
			unsigned int retimer_bus_id = board_i2c_bus_id_convert(board_params->retimer_bus_id);

			for (i = 0; i < 4; i++) {
				if (retimer_params[i].valid == AL_FALSE) {
					retimer_params[i].type = board_params->retimer_type;
					retimer_params[i].bus_id = retimer_bus_id;
					retimer_params[i].addr = board_params->retimer_i2c_addr;
					retimer_params[i].valid = AL_TRUE;
					break;
				} else if ((retimer_params[i].valid == AL_TRUE) &&
					(retimer_params[i].bus_id == retimer_bus_id) &&
					(retimer_params[i].addr == board_params->retimer_i2c_addr)) {
					if (retimer_params[i].type != board_params->retimer_type)
						printf("%s: DT indicates two different retimers on the same address\n", __func__);
					break;
				}
			}
		}
	}

	for (i = 0; i < 4; i++) {
		if (retimer_params[i].valid == AL_FALSE)
			break;

		err = al_eth_retimer_init(
					retimer_params[i].type,
					retimer_params[i].bus_id,
					retimer_params[i].addr);
		if (err) {
			/*
			 * retimer init failed - go over all ports with this retimer
			 * and mark it as not exist to make boards without retimer
			 * to work.
			 */
			for (port = 0; port < 4; port++) {
				struct al_eth_board_params *board_params =
					&al_globals.eth_board_params[port];
				unsigned int retimer_bus_id =
					board_i2c_bus_id_convert(board_params->retimer_bus_id);

				if ((board_params->retimer_exist == true) &&
				    (retimer_params[i].bus_id == retimer_bus_id) &&
				    (retimer_params[i].addr == board_params->retimer_i2c_addr)) {
					board_params->retimer_exist = false;
				}

			}
		}
	}

	return al_eth_pci_probe();
}
#endif

